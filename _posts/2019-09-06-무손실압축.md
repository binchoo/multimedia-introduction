# 무손실 압축

멀티미디어 프로세싱의 목적

압축한 결과에 대한 무손실 압축을 하기도 한다. 효율

## 압축이란

압축은 어떤 정보를 표현하기 위한 비트 수를 효율적으로 줄이고자 하는 것이다.

​         |디지탈 입력				  |비트 시퀀스            |새로운 비트 시퀀스      |전송  |디코딩 |입력되었던 것

- 비트 시퀀스 > 새로운 시퀀스
  - 에러 코렉션은 비트 시퀀스가 늘어나므로 압축이 아니다.
- 디코딩한 결과에 정보손실이 없으면 **무손실 압축**
- 디코딩한 결과에 정보변화가 있으면 **손실 압축**


### 압축률 (> 1)

$$
B_0 \over B_1
$$

### 정보 엔트로피

정보의 소스 $S=s_1,  s_2, ... , s_n$에 대하여 정보는 각 원소(심볼들)의 조합으로 나타나는데. i번째 심볼이 나타날 확률을 $p_i$라 하자. 정보엔트로피의 정의는 아래와 같다.
$$
H[p]=\sum{-p_i\log{p_i}}
$$

- 정보엔트로피는 정보를 인코딩할 때 소모될 비트에 대한 기댓값을 의미한다.
- 혹은 정보 심볼들을 코딩했을 때 평균 비트수의 최하한을 정의하게 된다.
- S를 2진수로 나타낼 때 필요한 비트의 양을 의미한다.
- 식에 의하면, 정보가 많을 때 비트가 많이 필요하고, 정보가 적을 때 비트가 조금 필요하다.
- 식에 의하면, **정보가 관측될 확률이 적을 때 그 정보는 중요한 정보이다.**
  - 문이 닫혀있을 때 0을 제너레이트하고 문이 열려있을 때 1을 제너레이트 한다면?
  - 그레이스케일 0~255가 상수로 분포한다고 하자. 즉 1/255이다. 그렇다면 해당 이미지의 엔트로피는 8이 나온다. 그러므로 8비트가 필요한 것이다!
- 비트 수의 하한 = 엔트로피보다 항상 크거나 같다. $ 1+n>l\ge n$
- 심볼 분포가 균등분포일 때 엔트로피가 가장 크게 나온다.

### 엔트로피 코딩

엔트로피 값에 근접하는 코드 길이를 생산하는, 최적의 인코딩을 일컫는다.

 

## Run-Length Coding

- Memoryless Source : 들어오는 정보는 서로 독립적이다. 앞에서 어떤 심볼이 나오던 간에 이번 심볼은 과거의 것들과 무관하다.
  - 동전 던지기 시행의 경우
- **Not** Memoryless Source :  RLC는 들어오는 정보가 앞 사건에 영향을 받는다고 가정한다. 
  - AAAAAAAA(8) BBBBBBBBB(9) CCCCC(5) AAAA(4)
  - 같은 심볼이 계속해서 나오는 RUN
  - 같은 심볼이 차지한 길이 LENGTH
  - 26개 심볼을 A8 B9 C4 A4라는 8심볼로 나타낼 수 있다.
  - 이런 방식의 코딩을 RLC라고 한다.

## Variable Length Coding

#### Huffman Coding (Entropy, Statictical Coding)

- 심볼들의 빈도를 파악해서 소팅한다.

```
C 8
A 8
T 6
D 3
O 2
G 2
```

- 가장 적은 빈도를 갖는 두 원소를 디큐한다.
- 두 원소를 자손으로 갖는 부모를 만든다. 부모의 값은 두 자손의 빈도 수 합이다.
- 반복한다.
- 도출된 트리에 코드워드를 할당하여 코드북을 작성한다.
- 빈도가 높은 심볼은 상위에 있어서 코드워드가 짧다.

- Unique Prefix Property : 모든 심볼은 리프가 되기 때문에 코드워드의 Prefix는 중복되지 않는다. 그래서 명확하다.

- Optimality : 주어진 데이타 모델에서 가장 최적방법이다. 심볼의 확률 분포가 정확히 주어져 있다면 허프만 코딩이 최적의 성능을 보여준다. **정수길이 코드워드를 배정하는 알고리즘에 한해서.**

- $n+1> l\ge n$ 이라서 엔트로피 코딩이라고 불린다.

#### Extended Huffman Coding

- 단일심볼을 사용하면 심볼 당 비트가 정수로만 떨어져서 엔트로피에 더 이상 다가갈 수 없다.
- **배치심볼을 사용하게 되면 엔트로피계산이 $n+1/s$이 되므로 배치크기가 늘어날 수록 심볼의 상한이 $n$ 에 수렴한다**
- 그래서 그냥 허프만보다 좋은 성능을 내게 된다.
- 단점은, 테이블의 엔트리가 6*6이 되어서 엄청나게 늘어난다.

> 자손을 만들 때 누굴 왼편으로 놓고 누굴 오른편으로 놓는가에 따라서 코드북이 다르게 나온다. 
>
> 그래서 디코더에게 코드북을 같이 전송해 줘야 한다.
>
> 그러므로 EHC는 엄청 긴 코드북을 전송하게 된다 -- 오히려 압축율이 떨어진다.



#### Adaptive Huffman Coding

- 심볼들의 빈도 = 확률에 대한 정보를 알고 있어야 허프만 코딩을 할 수 있음!

  - 현실적으로 사전에 파악하지 못 할 수도 있다.
  - 데이터 스트림을 동적으로 업데이트 한다. 심볼이 들어올 때마다 심볼의 count를 즉각 반영한다.

- *initial code* =  통계정보가 없을 때 사용하는 정보

  ```
  get(c) # c를 카운트한다.
  encode(c)
  update_tree(c) # 빈도 수에 의해 tree를 업데이트 한다.
  -- 
  decode(c)
  output(c) # 어떤 심볼인지 확인하고
  update_tree(c) # 트리를 업데이트 한다.
  ```
  
- 5비트(32개) 이면 알파벳을 모두 커버할 수 있다. 5비트 짜리 initial code를 사용한다.
  
- Tree Update 하는 법
  
  - 맨 아래쪽터 left to right 노드 번호를 매긴다. 번호 옆에 (frequency)를 적는다.
  - 트리의 특징은 sibling property를 유지 : **심볼이 작은 노드는 큰 노드보다 빈도가 클 수 없다**.
  - frequency count가 증가하여 sibling property가 깨지면 노드를 swap한다.
  - n이 n+1이 되면 가장 먼 n과 스와핑 한다.
  
- NEW 심볼 : 심볼이 initial code에서 온 것임을 알려주는 정보이다.

  ```
  A A D C C D D
  NEW_A A NEW_D NEW_C C D D D
  0 00001, 1, 0 00100, 00 00011, 001, 101, 101, ?
  ```
  
- 디코딩 과정은 어떻게 될까?

  ```
  1. 0이 오면 NEW 이다. 다음 심볼을 코드북에서 해석한다. 그렇지 않으면 트리에서 해석한다.
  3. 트리를 갱신한다.
  4. 반복한다.
  ```

## Dictionary Based Coding

#### LZW

- 새로운 데이터를 받을 때마다 이미 나왔던 값에 심볼을 덧붙여서 딕셔너리에 추가한다. 
- 처음엔 이니셜 딕셔너리 사용한다.

```python
s와 c
s = 맨 처음의 한 글자
while c가 끝에 닿을 때까지 :
 c = 다음 글자
 s + c가 dict 에 존재하면 :
  s = s + c
 else :
  s를 코드 값 으로 내보낸다.
  s + c 한 값을 dict에 추가한다.
  s = c
```

```
A B A B B A B C A B A B B A
output = A(1), B(2), AB(4), BA(5), B(2), C(3), BAB(7), BA(5)
dict = {
1 : A
2 : B
3 : C
4 : AB
5 : BA
6 : ABB
7 : BAB
8 : BC
9 : CB
10 : BABB
}
```

```python
s = None
while not EOF :
 k = 입력 값(인덱스)
 entry = k가 가리키는 값
 output = entry
 s 가 None이 아니면 :
  심볼 조합 s+entry[0]를 추가한다.
 s = entry
```
- 딕셔너리의 인덱스의 바이너리 코드를 할당하는 법 
  - 가변길이 $l_0$ ~ $l_{max}$ 를 갖는 코드를 사용한다.
  - 알파벳 이니셜 딕셔너리 코드는 5비트이다.
  - 딕셔너리에 자료를 추가하다가 엔트리가 부족해지면 비트를 늘린다.(용량 두 배 증가)
  - 더 이상 길이를 늘릴 수 없으면 무의미한 코드의 자리를 뺐는 식으로 구현할 수 있다.
    - 가장 옛날에 사용된 딕셔너리

## Arithmetic Coding

- 효율적이고 빠른, 통계기반의 압축기법. 
  - 허프만 코딩보다 좋은 성능을 보임. 
  - 길이 1 심볼에 대한 확률을 기반으로 메시지를 half-open interval $[a;b)$ 즉, **구간**으로 표현한다.
  - 메시지 하나에 코드워드 하나
- 일직선에 나타낸 확률분포 사용
  - main 분포과 같은 모습으로 sub 분포를 나눈다.
  - 각 심볼의 Range 정보를 인코더와 디코더가 가지고 있다.
  - 메시지의 심볼을 차례대로 입력받으며 확률구간을 계산한다.
  - 구간을 나타낼 수 있는 가장 작은 바이너리로 메시지를 코딩한다.

```
메시지 : C A E E $
메시지의 구간 :
구간을 나타내는 가장 작은 코드 : 
```
- 코드의 바이너리를 정하는 법

- 코드를 디코딩하는 법

  - 첫 문자를 파악한다. 그 문자의 Low Range만큼 뺄셈하고 그 문자의 Range의 역수를 곱한다.
  - 두 번째 문자를 파악한다. 그 문자의 Low Range만큼 뺄셈하고 그 문자의 Range의 역수를 곱한다. 
  - ..
  - 달러 심볼을 발견할 때 까지

## 이미지 무손실 압축

아날로그 영상을 디지털로 바꾸면 당연히 손실이 생기지만 그 디지털 영상을 압축할 때 무손실로 압축하는 방법이 있다는 소리이다.

- 왼편 픽셀과의 차분을 사용하거나
- 네 방향의 픽셀 값의 차분을 사용한다

### Spatial Redundancy

- 픽셀 값이 주위 픽셀들과 값의 차이가 크지 않다는 성질
- 차분 값들이 작은 값을 띄게 된다
- 원본 압축 vs 차분 압축
  - 원본을 압축하는 것보다 차분을 압축하는 것이 엔트로피가 적게 책정된다
  - 차분의 히스토그램을 보면 어느 한 값이 치우쳐 있기 때문이다
  - 그래서 더 적은 비트수로 표현할 수 있다.

### Lossless JPEG

- X 주위의 3개의 픽셀로 X 값을 예측하는 **7개의 Predictor**를 사용한다.
- 예측값과 실제값의 차이를 무손실 압축하여 전송한다