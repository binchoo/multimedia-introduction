# 손실 압축

손실 압축한 코드를 복원하면 원본 데이터의 **근사본**이 된다

비트레이트가 낮아지면 왜곡이 높아진다

허용할 수 있는 손실률에 대하여 가장 높은 압축률을 추구하자!

## Loseless의 제약

- 디코딩을 거치면 원본이 되는 것은 장점!

- 샤논의 정리에 의해서 비트 수가 **정보 엔트로피보다 작아질 수 없다**
- 30MB 사진을 1.5 압축률로 무손실 압축해 봤자 15MB
- 이런 용량의 한계를 벗어나는 것이 Lossy Compression이다

## Rate - Distortion Tradeoff

- 비트의 수를 줄인다 = 전송 **Bit Rate**가 낮아진다

- 정보의 손실이 생긴다 = 복원된 값에 **Distortion**이 있다

- 손실압축은 정보의 왜곡을 발생시킴. 
- 비트 레이트도 중요하지만, **왜곡의 발생을 제어하는 것도 중요**

### Distortion Measure

1. MSE
2. SNR (신호 대 잡음비)
  - $ \sigma^2_x$ 는 원본의 Average Squared Value 이고 
  - $\sigma^2_d$ 는 원본과 왜곡간의 MSE이다.
  - 사람의 인지체계를 고려하여 **데시벨을 사용**한다.
  - SNR이 높으면 왜곡이 적고, 작으면 왜곡이 크다.

$$
SNR = deci bell (\sigma^2_x, \sigma^2_d)
$$
  = 왜곡과 비교했을 때 원본 시그널이 충만한 정도 (웨버의 법칙이 고려되었음)

3. PSNR (Peak 신호 대 잡음비)
  - $ \sigma^2_x$ 대신에 $x_{peak}^2$ 을 사용한다.
  - 원본 신호 중에 가장 높은 값

### Rate - Distortion Curve 

- 압축률을 높이려고 하면 Distortion이 커지더라
-  == 전송 비트레이트를 줄이려 하면 Distortion이 커지더라 
- 좋은 압축 알고리즘은 Distortion이 천천히 증가

## Quantization = Distortion 주범

- 왜곡을 일으키는 주 원인
- 무한한 입력을 유한한 값으로 근사시키므로
- Scalar / Vector Quantizer
- Uniform / Non-Uniform Quantizer
  - NUQ는 Compader를 통과시킨 신호를  UQ에 넣는 것

### Uniform Scalar Quantizer

- 입력 범위를 동일 간격으로 나누어 대표값으로 매핑한다
- 대표값은 **구간의 중간값**으로 취한다. 이게 에러가 가장 적다.
- Decision Boundaries : 구간을 구분하는 값들
- Step Size : 균일한 구간 길이 

#### Midrise Qunatizer : 0에서 rise가 일어난다(그림 그려보셈)

- 0을 기준으로 좌우에 구간의 갯수가 동일하다
- 짝수 개의 구간(출력)

#### Midtread Qunatizer : 구간이 0을 밟고 지나간다. Dead Zone

- 0이 구간 속에 포함되며, 이 구간의 좌우에 동일한 수의 구간이 더 존재한다.
- 홀수 개의 구간(출력)
- dead zone : 0이 아닌 값을 0으로 만들어 버림 ㅋ
  - 0에서 미묘한 값들이 출렁일 때 사용하면 좋음

$$
Q_{midrise}(x) = ceil(x) - 0.5 \\
Q_{midtread}(x) = floor(x + 0.5)
$$

#### 양자화 에러를 줄이려면?

- **스텝크기를 입력에 맞추어 조정**할 수 있다면..

- 양자화기의 **수준** : 구간의 갯수가 M개이면 M수준이다
- **양자화 비트 수:** $ R =log_2M$
- **스텝 사이즈** : 입력의 구간 / M = $ 2X_{max}/M$

#### Granular(구간의 크기) Distortion = 양자화 에러

- **특정 구간을 갖는 입력**을 양자화했을 때 해당 구간의 평균적인 에러이다
  
  ​	ex) Midrise, M수준 양자화기의 그래뉼러 왜곡계산
  
- **구간 크기를 줄여라** 

  **= 구간의 수를 늘려라** 

  **= 비트 레이트를 올려리** 

  **= 잡음이 적어질 것이다**

### Non-Uniform Quantizer : Compander 사용

- **Com**pressor : 입력을 Response 공간(비선형적인 사람의 인지를 반영)으로 변환

- Ex**pan**der : Response를 원본 공간으로 되돌리는 함수
- Compander

### Vertor Quantization

- 무손실에서 심볼을 묶어서 압축했던 것 처럼 

- 여러 개를 묶어서 양자화하면 엔트로피를 더 작게 만들 수 있다
- 입력 값의 샘플을 이어붙인 n차원 벡터
- 벡터에 하나에 코드워드 하나를 매핑
  - 코드표를 보고 벡터와 **가장 비슷한 벡터**를 골라서 **lossy**하다
  - 가장 비슷한 벡터의 코드로 부호화한다

## Transform Coding

T에 의한 선형변환 Y = TX에 의하여 Y의 엔트리가 X의 엔트리보다 correlation이 적다면

Y를 코딩하는 것이 이득이다. 

DCT는 이미지를 다양한 주파수의 코사인 함수와 결합하여 단순한 공간으로 전이시킨다.

- 벡터 엔트리 간에는 상관관계가 있다. 
- 즉, 엔트리 개별적인 정보 합 > 벡터가 표현하는 정보량
- 엔트리 간 공통점을 찾아(decorrelate) 압축하자
- Energy Concentration : 정보의 대부분을 갖고 있는 엔트리
  - 가치가 많은 엔트리는 촘촘하게 양자화
  - 가치가 적은 엔트리는 듬성듬성, 혹은 빵으로 양자화
  - **DCT**
  - **KLT**

### Discrete Cosine Transform

공간 축에서 변화하는 픽셀 값 시그널은 다양한 주파수를 갖는 기저함수의 합으로 나타낼 수 있다. 

픽셀 값이 주파수에 대한 기저함수의 가중치로 변환된다.

- 공간 주파수 Spatial Frequency : 픽셀 블락에서(8픽셀들) 얼마나 값이 변하는지
- 공간 = Spatial Frequency가 다른 공간 주파수의 합
- DCT는 공간을 DC와 AC 컴포넌트의 합으로 나타낸다.
- IDCT는 DC와 AC 컴포넌트를 합쳐 원래 시그널로 변환한다.

#### DCT 정의

- x축 위치 i, y축 위치 j에 대하여 $f(i, j)$ 는 픽셀의 값을 의미함
- 가로 픽셀 수 M, 세로 픽셀 수 N
- 각 코사인 파는 basis function 이고 u, v 값에 의해 주파수가 정해진다.
  - u, v가 커지면 basis function이 빠르게 변화한다. 주파수가 빨라졌기 때문이다.
- M,N이 8,8이었다면 8가지의 basis function의 weighted sum으로 원래 픽셀값들의 시그널이 표현된다.
- 공간 주파수가 낮으면 픽셀 변화가 없다는 것이고, 공간 주파수가 높으면 픽셀 변화가 있다는 것이다.

- DCT는 선형변환이다! 
- 다른 p, q의 베이스함수를 다 곱해 더하면 0이 되고, 같은 p, q의 베이스함수를 다 곱해 더하면 1이된다. 직교성이 있다!

=> 좁은 구간에서 일어나는 픽셀 값의 변화는 모든 베이스 함수의 weigted sum이다. 가중치 F(u,v)를 구해서 곱해야 한다.

- 2D는 1D 베이스 함수 두 단위로 나눌 수가 있다. 이렇게 되면 64번 연산하던 걸 16번 연산으로 줄일 수 있다

#### DCT와 DFT와의 차이
 - DFT는 베이스 함수로 오일러 함수를 쓴다. 오일러 함수는 cos + i sin이다.
 - DCT는 코사인 베이스 함수를 사용한다.
 - 8개를 Symmetric하게 복붙하여 16개를 DFT 하는 것은, 8개를 DCT하는 것과 같다
 - 이미지에서 DFT 보다 DCT가 Energy Concentration을 잘 표현해서 적은 비트 수로 코딩할 수 있다.
